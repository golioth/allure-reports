{"uid":"e4d766cc6c7c928d","name":"test_connect","fullName":"tests.hil.tests.connection.test_connection#test_connect","historyId":"3cdc04226f35b75fda8cab7261db7d1f","time":{"start":1737043567288,"stop":1737043592930,"duration":25642},"status":"broken","statusMessage":"subprocess.CalledProcessError: Command '['stdbuf', '-o0', 'build/hil']' died with <Signals.SIGSEGV: 11>.","statusTrace":"self = <allure_commons._allure.fixture object at 0x7fbfa71883b0>, args = ()\nkwargs = {}\n\n    def __call__(self, *args, **kwargs):\n        self.parameters = func_parameters(self._fixture_function, *args, **kwargs)\n    \n        with self:\n>           return self._fixture_function(*args, **kwargs)\n\n../../../.local/lib/python3.12/site-packages/allure_commons/_allure.py:221: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../../.local/lib/python3.12/site-packages/anyio/pytest_plugin.py:98: in wrapper\n    yield from runner.run_asyncgen_fixture(local_func, kwargs)\n../../../.local/lib/python3.12/site-packages/anyio/_backends/_trio.py:953: in run_asyncgen_fixture\n    self._call_in_runner_task(asyncgen.asend, None)\n../../../.local/lib/python3.12/site-packages/anyio/_backends/_trio.py:940: in _call_in_runner_task\n    return outcome_holder[0].unwrap()\n../../../.local/lib/python3.12/site-packages/outcome/_impl.py:213: in unwrap\n    raise captured_error\n../../../.local/lib/python3.12/site-packages/anyio/_backends/_trio.py:910: in _run_tests_and_fixtures\n    retval = await coro\n../../../.local/lib/python3.12/site-packages/plugin.py:110: in board\n    async with board.started():\n/usr/lib/python3.12/contextlib.py:217: in __aexit__\n    await anext(self.gen)\n../../../.local/lib/python3.12/site-packages/linuxboard.py:19: in started\n    async with trio.open_nursery() as nursery:\n../../../.local/lib/python3.12/site-packages/trio/_core/_run.py:971: in __aexit__\n    raise combined_error_from_nursery\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncommand = ['stdbuf', '-o0', 'build/hil'], stdin = -1, capture_stdout = False\ncapture_stderr = False, check = True\ndeliver_cancel = <function _posix_deliver_cancel at 0x7fbfa77c7740>\ntask_status = <Task status object at 0x7fbfa71de0c0>\noptions = {'env': {'GOLIOTH_PSK': 'generated-IpptpmVDxJZgUCZi', 'GOLIOTH_PSK_ID': 'generated-IpptpmVDxJZgUCZi@firmware_ci'}, 'stdin': -1, 'stdout': -1}\nstdout_chunks = []\n\n    async def _run_process(\n        command: StrOrBytesPath | Sequence[StrOrBytesPath],\n        *,\n        stdin: bytes | bytearray | memoryview | int | HasFileno | None = b\"\",\n        capture_stdout: bool = False,\n        capture_stderr: bool = False,\n        check: bool = True,\n        deliver_cancel: Callable[[Process], Awaitable[object]] | None = None,\n        task_status: TaskStatus[Process] = trio.TASK_STATUS_IGNORED,\n        **options: object,\n    ) -> subprocess.CompletedProcess[bytes]:\n        \"\"\"Run ``command`` in a subprocess and wait for it to complete.\n    \n        This function can be called in two different ways.\n    \n        One option is a direct call, like::\n    \n            completed_process_info = await trio.run_process(...)\n    \n        In this case, it returns a :class:`subprocess.CompletedProcess` instance\n        describing the results. Use this if you want to treat a process like a\n        function call.\n    \n        The other option is to run it as a task using `Nursery.start` â€“ the enhanced version\n        of `~Nursery.start_soon` that lets a task pass back a value during startup::\n    \n            process = await nursery.start(trio.run_process, ...)\n    \n        In this case, `~Nursery.start` returns a `Process` object that you can use\n        to interact with the process while it's running. Use this if you want to\n        treat a process like a background task.\n    \n        Either way, `run_process` makes sure that the process has exited before\n        returning, handles cancellation, optionally checks for errors, and\n        provides some convenient shorthands for dealing with the child's\n        input/output.\n    \n        **Input:** `run_process` supports all the same ``stdin=`` arguments as\n        `subprocess.Popen`. In addition, if you simply want to pass in some fixed\n        data, you can pass a plain `bytes` object, and `run_process` will take\n        care of setting up a pipe, feeding in the data you gave, and then sending\n        end-of-file. The default is ``b\"\"``, which means that the child will receive\n        an empty stdin. If you want the child to instead read from the parent's\n        stdin, use ``stdin=None``.\n    \n        **Output:** By default, any output produced by the subprocess is\n        passed through to the standard output and error streams of the\n        parent Trio process.\n    \n        When calling `run_process` directly, you can capture the subprocess's output by\n        passing ``capture_stdout=True`` to capture the subprocess's standard output, and/or\n        ``capture_stderr=True`` to capture its standard error. Captured data is collected up\n        by Trio into an in-memory buffer, and then provided as the\n        :attr:`~subprocess.CompletedProcess.stdout` and/or\n        :attr:`~subprocess.CompletedProcess.stderr` attributes of the returned\n        :class:`~subprocess.CompletedProcess` object. The value for any stream that was not\n        captured will be ``None``.\n    \n        If you want to capture both stdout and stderr while keeping them\n        separate, pass ``capture_stdout=True, capture_stderr=True``.\n    \n        If you want to capture both stdout and stderr but mixed together\n        in the order they were printed, use: ``capture_stdout=True, stderr=subprocess.STDOUT``.\n        This directs the child's stderr into its stdout, so the combined\n        output will be available in the `~subprocess.CompletedProcess.stdout`\n        attribute.\n    \n        If you're using ``await nursery.start(trio.run_process, ...)`` and want to capture\n        the subprocess's output for further processing, then use ``stdout=subprocess.PIPE``\n        and then make sure to read the data out of the `Process.stdout` stream. If you want\n        to capture stderr separately, use ``stderr=subprocess.PIPE``. If you want to capture\n        both, but mixed together in the correct order, use ``stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT``.\n    \n        **Error checking:** If the subprocess exits with a nonzero status\n        code, indicating failure, :func:`run_process` raises a\n        :exc:`subprocess.CalledProcessError` exception rather than\n        returning normally. The captured outputs are still available as\n        the :attr:`~subprocess.CalledProcessError.stdout` and\n        :attr:`~subprocess.CalledProcessError.stderr` attributes of that\n        exception.  To disable this behavior, so that :func:`run_process`\n        returns normally even if the subprocess exits abnormally, pass ``check=False``.\n    \n        Note that this can make the ``capture_stdout`` and ``capture_stderr``\n        arguments useful even when starting `run_process` as a task: if you only\n        care about the output if the process fails, then you can enable capturing\n        and then read the output off of the `~subprocess.CalledProcessError`.\n    \n        **Cancellation:** If cancelled, `run_process` sends a termination\n        request to the subprocess, then waits for it to fully exit. The\n        ``deliver_cancel`` argument lets you control how the process is terminated.\n    \n        .. note:: `run_process` is intentionally similar to the standard library\n           `subprocess.run`, but some of the defaults are different. Specifically, we\n           default to:\n    \n           - ``check=True``, because `\"errors should never pass silently / unless\n             explicitly silenced\" <https://www.python.org/dev/peps/pep-0020/>`__.\n    \n           - ``stdin=b\"\"``, because it produces less-confusing results if a subprocess\n             unexpectedly tries to read from stdin.\n    \n           To get the `subprocess.run` semantics, use ``check=False, stdin=None``.\n    \n        Args:\n          command (list or str): The command to run. Typically this is a\n              sequence of strings such as ``['ls', '-l', 'directory with spaces']``,\n              where the first element names the executable to invoke and the other\n              elements specify its arguments. With ``shell=True`` in the\n              ``**options``, or on Windows, ``command`` may alternatively\n              be a string, which will be parsed following platform-dependent\n              :ref:`quoting rules <subprocess-quoting>`.\n    \n          stdin (:obj:`bytes`, subprocess.PIPE, file descriptor, or None): The\n              bytes to provide to the subprocess on its standard input stream, or\n              ``None`` if the subprocess's standard input should come from the\n              same place as the parent Trio process's standard input. As is the\n              case with the :mod:`subprocess` module, you can also pass a file\n              descriptor or an object with a ``fileno()`` method, in which case\n              the subprocess's standard input will come from that file.\n    \n              When starting `run_process` as a background task, you can also use\n              ``stdin=subprocess.PIPE``, in which case `Process.stdin` will be a\n              `~trio.abc.SendStream` that you can use to send data to the child.\n    \n          capture_stdout (bool): If true, capture the bytes that the subprocess\n              writes to its standard output stream and return them in the\n              `~subprocess.CompletedProcess.stdout` attribute of the returned\n              `subprocess.CompletedProcess` or `subprocess.CalledProcessError`.\n    \n          capture_stderr (bool): If true, capture the bytes that the subprocess\n              writes to its standard error stream and return them in the\n              `~subprocess.CompletedProcess.stderr` attribute of the returned\n              `~subprocess.CompletedProcess` or `subprocess.CalledProcessError`.\n    \n          check (bool): If false, don't validate that the subprocess exits\n              successfully. You should be sure to check the\n              ``returncode`` attribute of the returned object if you pass\n              ``check=False``, so that errors don't pass silently.\n    \n          deliver_cancel (async function or None): If `run_process` is cancelled,\n              then it needs to kill the child process. There are multiple ways to\n              do this, so we let you customize it.\n    \n              If you pass None (the default), then the behavior depends on the\n              platform:\n    \n              - On Windows, Trio calls ``TerminateProcess``, which should kill the\n                process immediately.\n    \n              - On Unix-likes, the default behavior is to send a ``SIGTERM``, wait\n                5 seconds, and send a ``SIGKILL``.\n    \n              Alternatively, you can customize this behavior by passing in an\n              arbitrary async function, which will be called with the `Process`\n              object as an argument. For example, the default Unix behavior could\n              be implemented like this::\n    \n                 async def my_deliver_cancel(process):\n                     process.send_signal(signal.SIGTERM)\n                     await trio.sleep(5)\n                     process.send_signal(signal.SIGKILL)\n    \n              When the process actually exits, the ``deliver_cancel`` function\n              will automatically be cancelled â€“ so if the process exits after\n              ``SIGTERM``, then we'll never reach the ``SIGKILL``.\n    \n              In any case, `run_process` will always wait for the child process to\n              exit before raising `Cancelled`.\n    \n          **options: :func:`run_process` also accepts any :ref:`general subprocess\n              options <subprocess-options>` and passes them on to the\n              :class:`~trio.Process` constructor. This includes the\n              ``stdout`` and ``stderr`` options, which provide additional\n              redirection possibilities such as ``stderr=subprocess.STDOUT``,\n              ``stdout=subprocess.DEVNULL``, or file descriptors.\n    \n        Returns:\n    \n          When called normally â€“ a `subprocess.CompletedProcess` instance\n          describing the return code and outputs.\n    \n          When called via `Nursery.start` â€“ a `trio.Process` instance.\n    \n        Raises:\n          UnicodeError: if ``stdin`` is specified as a Unicode string, rather\n              than bytes\n          ValueError: if multiple redirections are specified for the same\n              stream, e.g., both ``capture_stdout=True`` and\n              ``stdout=subprocess.DEVNULL``\n          subprocess.CalledProcessError: if ``check=False`` is not passed\n              and the process exits with a nonzero exit status\n          OSError: if an error is encountered starting or communicating with\n              the process\n    \n        .. note:: The child process runs in the same process group as the parent\n           Trio process, so a Ctrl+C will be delivered simultaneously to both\n           parent and child. If you don't want this behavior, consult your\n           platform's documentation for starting child processes in a different\n           process group.\n    \n        \"\"\"\n    \n        if isinstance(stdin, str):\n            raise UnicodeError(\"process stdin must be bytes, not str\")\n        if task_status is trio.TASK_STATUS_IGNORED:\n            if stdin is subprocess.PIPE:\n                raise ValueError(\n                    \"stdout=subprocess.PIPE is only valid with nursery.start, \"\n                    \"since that's the only way to access the pipe; use nursery.start \"\n                    \"or pass the data you want to write directly\"\n                )\n            if options.get(\"stdout\") is subprocess.PIPE:\n                raise ValueError(\n                    \"stdout=subprocess.PIPE is only valid with nursery.start, \"\n                    \"since that's the only way to access the pipe\"\n                )\n            if options.get(\"stderr\") is subprocess.PIPE:\n                raise ValueError(\n                    \"stderr=subprocess.PIPE is only valid with nursery.start, \"\n                    \"since that's the only way to access the pipe\"\n                )\n        if isinstance(stdin, (bytes, bytearray, memoryview)):\n            input = stdin\n            options[\"stdin\"] = subprocess.PIPE\n        else:\n            # stdin should be something acceptable to Process\n            # (None, DEVNULL, a file descriptor, etc) and Process\n            # will raise if it's not\n            input = None\n            options[\"stdin\"] = stdin\n    \n        if capture_stdout:\n            if \"stdout\" in options:\n                raise ValueError(\"can't specify both stdout and capture_stdout\")\n            options[\"stdout\"] = subprocess.PIPE\n        if capture_stderr:\n            if \"stderr\" in options:\n                raise ValueError(\"can't specify both stderr and capture_stderr\")\n            options[\"stderr\"] = subprocess.PIPE\n    \n        if deliver_cancel is None:\n            if os.name == \"nt\":\n                deliver_cancel = _windows_deliver_cancel\n            else:\n                assert os.name == \"posix\"\n                deliver_cancel = _posix_deliver_cancel\n    \n        stdout_chunks: list[bytes | bytearray] = []\n        stderr_chunks: list[bytes | bytearray] = []\n    \n        async def feed_input(stream: SendStream) -> None:\n            async with stream:\n                try:\n                    assert input is not None\n                    await stream.send_all(input)\n                except trio.BrokenResourceError:\n                    pass\n    \n        async def read_output(\n            stream: ReceiveStream,\n            chunks: list[bytes | bytearray],\n        ) -> None:\n            async with stream:\n                async for chunk in stream:\n                    chunks.append(chunk)\n    \n        async with trio.open_nursery() as nursery:\n            # options needs a complex TypedDict. The overload error only occurs on Unix.\n            proc = await open_process(command, **options)  # type: ignore[arg-type, call-overload, unused-ignore]\n            try:\n                if input is not None:\n                    assert proc.stdin is not None\n                    nursery.start_soon(feed_input, proc.stdin)\n                    proc.stdin = None\n                    proc.stdio = None\n                if capture_stdout:\n                    assert proc.stdout is not None\n                    nursery.start_soon(read_output, proc.stdout, stdout_chunks)\n                    proc.stdout = None\n                    proc.stdio = None\n                if capture_stderr:\n                    assert proc.stderr is not None\n                    nursery.start_soon(read_output, proc.stderr, stderr_chunks)\n                    proc.stderr = None\n                task_status.started(proc)\n                await proc.wait()\n            except BaseException:\n                with trio.CancelScope(shield=True):\n                    killer_cscope = trio.CancelScope(shield=True)\n    \n                    async def killer() -> None:\n                        with killer_cscope:\n                            await deliver_cancel(proc)\n    \n                    nursery.start_soon(killer)\n                    await proc.wait()\n                    killer_cscope.cancel()\n                    raise\n    \n        stdout = b\"\".join(stdout_chunks) if capture_stdout else None\n        stderr = b\"\".join(stderr_chunks) if capture_stderr else None\n    \n        if proc.returncode and check:\n>           raise subprocess.CalledProcessError(\n                proc.returncode, proc.args, output=stdout, stderr=stderr\n            )\nE           subprocess.CalledProcessError: Command '['stdbuf', '-o0', 'build/hil']' died with <Signals.SIGSEGV: 11>.\n\n../../../.local/lib/python3.12/site-packages/trio/_subprocess.py:765: CalledProcessError","flaky":false,"newFailed":false,"newBroken":true,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"board_name","time":{"start":1737043566154,"stop":1737043566154,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"serial_number","time":{"start":1737043566154,"stop":1737043566154,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"baud","time":{"start":1737043566154,"stop":1737043566154,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"device_name","time":{"start":1737043566154,"stop":1737043566154,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"anyio_backend","time":{"start":1737043566154,"stop":1737043566154,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"fw_image","time":{"start":1737043566154,"stop":1737043566154,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"wifi_psk","time":{"start":1737043566154,"stop":1737043566154,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"port","time":{"start":1737043566154,"stop":1737043566154,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"bmp_port","time":{"start":1737043566154,"stop":1737043566154,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"wifi_ssid","time":{"start":1737043566154,"stop":1737043566154,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"api_url","time":{"start":1737043566155,"stop":1737043566155,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"board","time":{"start":1737043566155,"stop":1737043566176,"duration":21},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"api_key","time":{"start":1737043566155,"stop":1737043566155,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"project","time":{"start":1737043566176,"stop":1737043566529,"duration":353},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"device","time":{"start":1737043566529,"stop":1737043567287,"duration":758},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"testStage":{"status":"broken","statusMessage":"subprocess.CalledProcessError: Command '['stdbuf', '-o0', 'build/hil']' died with <Signals.SIGSEGV: 11>.","statusTrace":"self = <allure_commons._allure.fixture object at 0x7fbfa71883b0>, args = ()\nkwargs = {}\n\n    def __call__(self, *args, **kwargs):\n        self.parameters = func_parameters(self._fixture_function, *args, **kwargs)\n    \n        with self:\n>           return self._fixture_function(*args, **kwargs)\n\n../../../.local/lib/python3.12/site-packages/allure_commons/_allure.py:221: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../../.local/lib/python3.12/site-packages/anyio/pytest_plugin.py:98: in wrapper\n    yield from runner.run_asyncgen_fixture(local_func, kwargs)\n../../../.local/lib/python3.12/site-packages/anyio/_backends/_trio.py:953: in run_asyncgen_fixture\n    self._call_in_runner_task(asyncgen.asend, None)\n../../../.local/lib/python3.12/site-packages/anyio/_backends/_trio.py:940: in _call_in_runner_task\n    return outcome_holder[0].unwrap()\n../../../.local/lib/python3.12/site-packages/outcome/_impl.py:213: in unwrap\n    raise captured_error\n../../../.local/lib/python3.12/site-packages/anyio/_backends/_trio.py:910: in _run_tests_and_fixtures\n    retval = await coro\n../../../.local/lib/python3.12/site-packages/plugin.py:110: in board\n    async with board.started():\n/usr/lib/python3.12/contextlib.py:217: in __aexit__\n    await anext(self.gen)\n../../../.local/lib/python3.12/site-packages/linuxboard.py:19: in started\n    async with trio.open_nursery() as nursery:\n../../../.local/lib/python3.12/site-packages/trio/_core/_run.py:971: in __aexit__\n    raise combined_error_from_nursery\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncommand = ['stdbuf', '-o0', 'build/hil'], stdin = -1, capture_stdout = False\ncapture_stderr = False, check = True\ndeliver_cancel = <function _posix_deliver_cancel at 0x7fbfa77c7740>\ntask_status = <Task status object at 0x7fbfa71de0c0>\noptions = {'env': {'GOLIOTH_PSK': 'generated-IpptpmVDxJZgUCZi', 'GOLIOTH_PSK_ID': 'generated-IpptpmVDxJZgUCZi@firmware_ci'}, 'stdin': -1, 'stdout': -1}\nstdout_chunks = []\n\n    async def _run_process(\n        command: StrOrBytesPath | Sequence[StrOrBytesPath],\n        *,\n        stdin: bytes | bytearray | memoryview | int | HasFileno | None = b\"\",\n        capture_stdout: bool = False,\n        capture_stderr: bool = False,\n        check: bool = True,\n        deliver_cancel: Callable[[Process], Awaitable[object]] | None = None,\n        task_status: TaskStatus[Process] = trio.TASK_STATUS_IGNORED,\n        **options: object,\n    ) -> subprocess.CompletedProcess[bytes]:\n        \"\"\"Run ``command`` in a subprocess and wait for it to complete.\n    \n        This function can be called in two different ways.\n    \n        One option is a direct call, like::\n    \n            completed_process_info = await trio.run_process(...)\n    \n        In this case, it returns a :class:`subprocess.CompletedProcess` instance\n        describing the results. Use this if you want to treat a process like a\n        function call.\n    \n        The other option is to run it as a task using `Nursery.start` â€“ the enhanced version\n        of `~Nursery.start_soon` that lets a task pass back a value during startup::\n    \n            process = await nursery.start(trio.run_process, ...)\n    \n        In this case, `~Nursery.start` returns a `Process` object that you can use\n        to interact with the process while it's running. Use this if you want to\n        treat a process like a background task.\n    \n        Either way, `run_process` makes sure that the process has exited before\n        returning, handles cancellation, optionally checks for errors, and\n        provides some convenient shorthands for dealing with the child's\n        input/output.\n    \n        **Input:** `run_process` supports all the same ``stdin=`` arguments as\n        `subprocess.Popen`. In addition, if you simply want to pass in some fixed\n        data, you can pass a plain `bytes` object, and `run_process` will take\n        care of setting up a pipe, feeding in the data you gave, and then sending\n        end-of-file. The default is ``b\"\"``, which means that the child will receive\n        an empty stdin. If you want the child to instead read from the parent's\n        stdin, use ``stdin=None``.\n    \n        **Output:** By default, any output produced by the subprocess is\n        passed through to the standard output and error streams of the\n        parent Trio process.\n    \n        When calling `run_process` directly, you can capture the subprocess's output by\n        passing ``capture_stdout=True`` to capture the subprocess's standard output, and/or\n        ``capture_stderr=True`` to capture its standard error. Captured data is collected up\n        by Trio into an in-memory buffer, and then provided as the\n        :attr:`~subprocess.CompletedProcess.stdout` and/or\n        :attr:`~subprocess.CompletedProcess.stderr` attributes of the returned\n        :class:`~subprocess.CompletedProcess` object. The value for any stream that was not\n        captured will be ``None``.\n    \n        If you want to capture both stdout and stderr while keeping them\n        separate, pass ``capture_stdout=True, capture_stderr=True``.\n    \n        If you want to capture both stdout and stderr but mixed together\n        in the order they were printed, use: ``capture_stdout=True, stderr=subprocess.STDOUT``.\n        This directs the child's stderr into its stdout, so the combined\n        output will be available in the `~subprocess.CompletedProcess.stdout`\n        attribute.\n    \n        If you're using ``await nursery.start(trio.run_process, ...)`` and want to capture\n        the subprocess's output for further processing, then use ``stdout=subprocess.PIPE``\n        and then make sure to read the data out of the `Process.stdout` stream. If you want\n        to capture stderr separately, use ``stderr=subprocess.PIPE``. If you want to capture\n        both, but mixed together in the correct order, use ``stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT``.\n    \n        **Error checking:** If the subprocess exits with a nonzero status\n        code, indicating failure, :func:`run_process` raises a\n        :exc:`subprocess.CalledProcessError` exception rather than\n        returning normally. The captured outputs are still available as\n        the :attr:`~subprocess.CalledProcessError.stdout` and\n        :attr:`~subprocess.CalledProcessError.stderr` attributes of that\n        exception.  To disable this behavior, so that :func:`run_process`\n        returns normally even if the subprocess exits abnormally, pass ``check=False``.\n    \n        Note that this can make the ``capture_stdout`` and ``capture_stderr``\n        arguments useful even when starting `run_process` as a task: if you only\n        care about the output if the process fails, then you can enable capturing\n        and then read the output off of the `~subprocess.CalledProcessError`.\n    \n        **Cancellation:** If cancelled, `run_process` sends a termination\n        request to the subprocess, then waits for it to fully exit. The\n        ``deliver_cancel`` argument lets you control how the process is terminated.\n    \n        .. note:: `run_process` is intentionally similar to the standard library\n           `subprocess.run`, but some of the defaults are different. Specifically, we\n           default to:\n    \n           - ``check=True``, because `\"errors should never pass silently / unless\n             explicitly silenced\" <https://www.python.org/dev/peps/pep-0020/>`__.\n    \n           - ``stdin=b\"\"``, because it produces less-confusing results if a subprocess\n             unexpectedly tries to read from stdin.\n    \n           To get the `subprocess.run` semantics, use ``check=False, stdin=None``.\n    \n        Args:\n          command (list or str): The command to run. Typically this is a\n              sequence of strings such as ``['ls', '-l', 'directory with spaces']``,\n              where the first element names the executable to invoke and the other\n              elements specify its arguments. With ``shell=True`` in the\n              ``**options``, or on Windows, ``command`` may alternatively\n              be a string, which will be parsed following platform-dependent\n              :ref:`quoting rules <subprocess-quoting>`.\n    \n          stdin (:obj:`bytes`, subprocess.PIPE, file descriptor, or None): The\n              bytes to provide to the subprocess on its standard input stream, or\n              ``None`` if the subprocess's standard input should come from the\n              same place as the parent Trio process's standard input. As is the\n              case with the :mod:`subprocess` module, you can also pass a file\n              descriptor or an object with a ``fileno()`` method, in which case\n              the subprocess's standard input will come from that file.\n    \n              When starting `run_process` as a background task, you can also use\n              ``stdin=subprocess.PIPE``, in which case `Process.stdin` will be a\n              `~trio.abc.SendStream` that you can use to send data to the child.\n    \n          capture_stdout (bool): If true, capture the bytes that the subprocess\n              writes to its standard output stream and return them in the\n              `~subprocess.CompletedProcess.stdout` attribute of the returned\n              `subprocess.CompletedProcess` or `subprocess.CalledProcessError`.\n    \n          capture_stderr (bool): If true, capture the bytes that the subprocess\n              writes to its standard error stream and return them in the\n              `~subprocess.CompletedProcess.stderr` attribute of the returned\n              `~subprocess.CompletedProcess` or `subprocess.CalledProcessError`.\n    \n          check (bool): If false, don't validate that the subprocess exits\n              successfully. You should be sure to check the\n              ``returncode`` attribute of the returned object if you pass\n              ``check=False``, so that errors don't pass silently.\n    \n          deliver_cancel (async function or None): If `run_process` is cancelled,\n              then it needs to kill the child process. There are multiple ways to\n              do this, so we let you customize it.\n    \n              If you pass None (the default), then the behavior depends on the\n              platform:\n    \n              - On Windows, Trio calls ``TerminateProcess``, which should kill the\n                process immediately.\n    \n              - On Unix-likes, the default behavior is to send a ``SIGTERM``, wait\n                5 seconds, and send a ``SIGKILL``.\n    \n              Alternatively, you can customize this behavior by passing in an\n              arbitrary async function, which will be called with the `Process`\n              object as an argument. For example, the default Unix behavior could\n              be implemented like this::\n    \n                 async def my_deliver_cancel(process):\n                     process.send_signal(signal.SIGTERM)\n                     await trio.sleep(5)\n                     process.send_signal(signal.SIGKILL)\n    \n              When the process actually exits, the ``deliver_cancel`` function\n              will automatically be cancelled â€“ so if the process exits after\n              ``SIGTERM``, then we'll never reach the ``SIGKILL``.\n    \n              In any case, `run_process` will always wait for the child process to\n              exit before raising `Cancelled`.\n    \n          **options: :func:`run_process` also accepts any :ref:`general subprocess\n              options <subprocess-options>` and passes them on to the\n              :class:`~trio.Process` constructor. This includes the\n              ``stdout`` and ``stderr`` options, which provide additional\n              redirection possibilities such as ``stderr=subprocess.STDOUT``,\n              ``stdout=subprocess.DEVNULL``, or file descriptors.\n    \n        Returns:\n    \n          When called normally â€“ a `subprocess.CompletedProcess` instance\n          describing the return code and outputs.\n    \n          When called via `Nursery.start` â€“ a `trio.Process` instance.\n    \n        Raises:\n          UnicodeError: if ``stdin`` is specified as a Unicode string, rather\n              than bytes\n          ValueError: if multiple redirections are specified for the same\n              stream, e.g., both ``capture_stdout=True`` and\n              ``stdout=subprocess.DEVNULL``\n          subprocess.CalledProcessError: if ``check=False`` is not passed\n              and the process exits with a nonzero exit status\n          OSError: if an error is encountered starting or communicating with\n              the process\n    \n        .. note:: The child process runs in the same process group as the parent\n           Trio process, so a Ctrl+C will be delivered simultaneously to both\n           parent and child. If you don't want this behavior, consult your\n           platform's documentation for starting child processes in a different\n           process group.\n    \n        \"\"\"\n    \n        if isinstance(stdin, str):\n            raise UnicodeError(\"process stdin must be bytes, not str\")\n        if task_status is trio.TASK_STATUS_IGNORED:\n            if stdin is subprocess.PIPE:\n                raise ValueError(\n                    \"stdout=subprocess.PIPE is only valid with nursery.start, \"\n                    \"since that's the only way to access the pipe; use nursery.start \"\n                    \"or pass the data you want to write directly\"\n                )\n            if options.get(\"stdout\") is subprocess.PIPE:\n                raise ValueError(\n                    \"stdout=subprocess.PIPE is only valid with nursery.start, \"\n                    \"since that's the only way to access the pipe\"\n                )\n            if options.get(\"stderr\") is subprocess.PIPE:\n                raise ValueError(\n                    \"stderr=subprocess.PIPE is only valid with nursery.start, \"\n                    \"since that's the only way to access the pipe\"\n                )\n        if isinstance(stdin, (bytes, bytearray, memoryview)):\n            input = stdin\n            options[\"stdin\"] = subprocess.PIPE\n        else:\n            # stdin should be something acceptable to Process\n            # (None, DEVNULL, a file descriptor, etc) and Process\n            # will raise if it's not\n            input = None\n            options[\"stdin\"] = stdin\n    \n        if capture_stdout:\n            if \"stdout\" in options:\n                raise ValueError(\"can't specify both stdout and capture_stdout\")\n            options[\"stdout\"] = subprocess.PIPE\n        if capture_stderr:\n            if \"stderr\" in options:\n                raise ValueError(\"can't specify both stderr and capture_stderr\")\n            options[\"stderr\"] = subprocess.PIPE\n    \n        if deliver_cancel is None:\n            if os.name == \"nt\":\n                deliver_cancel = _windows_deliver_cancel\n            else:\n                assert os.name == \"posix\"\n                deliver_cancel = _posix_deliver_cancel\n    \n        stdout_chunks: list[bytes | bytearray] = []\n        stderr_chunks: list[bytes | bytearray] = []\n    \n        async def feed_input(stream: SendStream) -> None:\n            async with stream:\n                try:\n                    assert input is not None\n                    await stream.send_all(input)\n                except trio.BrokenResourceError:\n                    pass\n    \n        async def read_output(\n            stream: ReceiveStream,\n            chunks: list[bytes | bytearray],\n        ) -> None:\n            async with stream:\n                async for chunk in stream:\n                    chunks.append(chunk)\n    \n        async with trio.open_nursery() as nursery:\n            # options needs a complex TypedDict. The overload error only occurs on Unix.\n            proc = await open_process(command, **options)  # type: ignore[arg-type, call-overload, unused-ignore]\n            try:\n                if input is not None:\n                    assert proc.stdin is not None\n                    nursery.start_soon(feed_input, proc.stdin)\n                    proc.stdin = None\n                    proc.stdio = None\n                if capture_stdout:\n                    assert proc.stdout is not None\n                    nursery.start_soon(read_output, proc.stdout, stdout_chunks)\n                    proc.stdout = None\n                    proc.stdio = None\n                if capture_stderr:\n                    assert proc.stderr is not None\n                    nursery.start_soon(read_output, proc.stderr, stderr_chunks)\n                    proc.stderr = None\n                task_status.started(proc)\n                await proc.wait()\n            except BaseException:\n                with trio.CancelScope(shield=True):\n                    killer_cscope = trio.CancelScope(shield=True)\n    \n                    async def killer() -> None:\n                        with killer_cscope:\n                            await deliver_cancel(proc)\n    \n                    nursery.start_soon(killer)\n                    await proc.wait()\n                    killer_cscope.cancel()\n                    raise\n    \n        stdout = b\"\".join(stdout_chunks) if capture_stdout else None\n        stderr = b\"\".join(stderr_chunks) if capture_stderr else None\n    \n        if proc.returncode and check:\n>           raise subprocess.CalledProcessError(\n                proc.returncode, proc.args, output=stdout, stderr=stderr\n            )\nE           subprocess.CalledProcessError: Command '['stdbuf', '-o0', 'build/hil']' died with <Signals.SIGSEGV: 11>.\n\n../../../.local/lib/python3.12/site-packages/trio/_subprocess.py:765: CalledProcessError","steps":[],"attachments":[{"uid":"3c599fc4c1f255c4","name":"stdout","source":"3c599fc4c1f255c4.txt","type":"text/plain","size":2670}],"parameters":[],"shouldDisplayMessage":true,"stepsCount":0,"attachmentsCount":1,"hasContent":true,"attachmentStep":false},"afterStages":[{"name":"device::0","time":{"start":1737043592936,"stop":1737043593156,"duration":220},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"project::0","time":{"start":1737043593157,"stop":1737043593157,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"board::0","time":{"start":1737043593157,"stop":1737043593311,"duration":154},"status":"broken","statusMessage":"subprocess.CalledProcessError: Command '['stdbuf', '-o0', 'build/hil']' died with <Signals.SIGSEGV: 11>.\n","statusTrace":"  File \"/home/runner/.local/lib/python3.12/site-packages/allure_commons/_allure.py\", line 221, in __call__\n    return self._fixture_function(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/runner/.local/lib/python3.12/site-packages/_pytest/fixtures.py\", line 907, in _teardown_yield_fixture\n    next(it)\n  File \"/home/runner/.local/lib/python3.12/site-packages/anyio/pytest_plugin.py\", line 98, in wrapper\n    yield from runner.run_asyncgen_fixture(local_func, kwargs)\n  File \"/home/runner/.local/lib/python3.12/site-packages/anyio/_backends/_trio.py\", line 953, in run_asyncgen_fixture\n    self._call_in_runner_task(asyncgen.asend, None)\n  File \"/home/runner/.local/lib/python3.12/site-packages/anyio/_backends/_trio.py\", line 940, in _call_in_runner_task\n    return outcome_holder[0].unwrap()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/runner/.local/lib/python3.12/site-packages/outcome/_impl.py\", line 213, in unwrap\n    raise captured_error\n  File \"/home/runner/.local/lib/python3.12/site-packages/anyio/_backends/_trio.py\", line 910, in _run_tests_and_fixtures\n    retval = await coro\n             ^^^^^^^^^^\n  File \"/home/runner/.local/lib/python3.12/site-packages/plugin.py\", line 110, in board\n    async with board.started():\n  File \"/usr/lib/python3.12/contextlib.py\", line 217, in __aexit__\n    await anext(self.gen)\n  File \"/home/runner/.local/lib/python3.12/site-packages/linuxboard.py\", line 19, in started\n    async with trio.open_nursery() as nursery:\n  File \"/home/runner/.local/lib/python3.12/site-packages/trio/_core/_run.py\", line 971, in __aexit__\n    raise combined_error_from_nursery\n  File \"/home/runner/.local/lib/python3.12/site-packages/trio/_subprocess.py\", line 765, in _run_process\n    raise subprocess.CalledProcessError(\n","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":true,"stepsCount":0,"attachmentsCount":0,"hasContent":true,"attachmentStep":false}],"labels":[{"name":"tag","value":"linux"},{"name":"tag","value":"linux"},{"name":"parentSuite","value":"hil.linux.linux"},{"name":"tag"},{"name":"tag","value":"@pytest.mark.usefixtures('anyio_backend')"},{"name":"tag","value":"anyio"},{"name":"suite","value":"test_connection"},{"name":"host","value":"fv-az1344-93"},{"name":"thread","value":"3714-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.hil.tests.connection.test_connection"},{"name":"resultFormat","value":"allure2"}],"parameters":[{"name":"board_name","value":"'linux'"},{"name":"platform_name","value":"'linux'"}],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Test defects","matchedStatuses":[],"flaky":false}],"history":{"statistic":{"failed":0,"broken":4,"skipped":0,"passed":86,"unknown":0,"total":90},"items":[{"uid":"198c08d6bc00290d","reportUrl":"https://golioth.github.io/allure-reports/recurring/83//#testresult/198c08d6bc00290d","status":"passed","time":{"start":1737029312175,"stop":1737029337791,"duration":25616}},{"uid":"b3d21980397d82c9","reportUrl":"https://golioth.github.io/allure-reports/recurring/82//#testresult/b3d21980397d82c9","status":"passed","time":{"start":1737014792935,"stop":1737014818464,"duration":25529}},{"uid":"839d32f6580ca3f","reportUrl":"https://golioth.github.io/allure-reports/recurring/81//#testresult/839d32f6580ca3f","status":"passed","time":{"start":1737000386667,"stop":1737000412169,"duration":25502}},{"uid":"6bc6e3084fe0f762","reportUrl":"https://golioth.github.io/allure-reports/recurring/80//#testresult/6bc6e3084fe0f762","status":"passed","time":{"start":1736986828323,"stop":1736986853526,"duration":25203}},{"uid":"9c80b0cf0624f88a","reportUrl":"https://golioth.github.io/allure-reports/recurring/79//#testresult/9c80b0cf0624f88a","status":"passed","time":{"start":1736971543298,"stop":1736971568091,"duration":24793}},{"uid":"3fb2fa55f60337f5","reportUrl":"https://golioth.github.io/allure-reports/recurring/78//#testresult/3fb2fa55f60337f5","status":"passed","time":{"start":1736957171308,"stop":1736957196645,"duration":25337}},{"uid":"44748454d3c06008","reportUrl":"https://golioth.github.io/allure-reports/recurring/77//#testresult/44748454d3c06008","status":"passed","time":{"start":1736942909977,"stop":1736942935713,"duration":25736}},{"uid":"47ff1c65dcce4c2b","reportUrl":"https://golioth.github.io/allure-reports/recurring/76//#testresult/47ff1c65dcce4c2b","status":"passed","time":{"start":1736928433439,"stop":1736928458606,"duration":25167}},{"uid":"9ed851ae942d4647","reportUrl":"https://golioth.github.io/allure-reports/recurring/75//#testresult/9ed851ae942d4647","status":"passed","time":{"start":1736913981631,"stop":1736914006830,"duration":25199}},{"uid":"263a51bf78835cb4","reportUrl":"https://golioth.github.io/allure-reports/recurring/74//#testresult/263a51bf78835cb4","status":"passed","time":{"start":1736900441682,"stop":1736900466795,"duration":25113}},{"uid":"d7b2fb3263623049","reportUrl":"https://golioth.github.io/allure-reports/recurring/73//#testresult/d7b2fb3263623049","status":"passed","time":{"start":1736885165321,"stop":1736885190696,"duration":25375}},{"uid":"99f6a6ea900b14e1","reportUrl":"https://golioth.github.io/allure-reports/recurring/72//#testresult/99f6a6ea900b14e1","status":"passed","time":{"start":1736870778258,"stop":1736870803429,"duration":25171}},{"uid":"4fa9a4f999cd5df1","reportUrl":"https://golioth.github.io/allure-reports/recurring/71//#testresult/4fa9a4f999cd5df1","status":"passed","time":{"start":1736856505841,"stop":1736856531116,"duration":25275}},{"uid":"dc01afd9eeeb596a","reportUrl":"https://golioth.github.io/allure-reports/recurring/70//#testresult/dc01afd9eeeb596a","status":"passed","time":{"start":1736842052386,"stop":1736842077616,"duration":25230}},{"uid":"56313d88c184fbc1","reportUrl":"https://golioth.github.io/allure-reports/recurring/69//#testresult/56313d88c184fbc1","status":"passed","time":{"start":1736827583963,"stop":1736827609450,"duration":25487}},{"uid":"6f1fc4febde49912","reportUrl":"https://golioth.github.io/allure-reports/recurring/68//#testresult/6f1fc4febde49912","status":"passed","time":{"start":1736814291017,"stop":1736814316232,"duration":25215}},{"uid":"aa61829830f275f9","reportUrl":"https://golioth.github.io/allure-reports/recurring/67//#testresult/aa61829830f275f9","status":"passed","time":{"start":1736798734778,"stop":1736798759871,"duration":25093}},{"uid":"25c95f81c7ee10de","reportUrl":"https://golioth.github.io/allure-reports/recurring/66//#testresult/25c95f81c7ee10de","status":"passed","time":{"start":1736784398026,"stop":1736784423140,"duration":25114}},{"uid":"3b6fd8b83454488b","reportUrl":"https://golioth.github.io/allure-reports/recurring/65//#testresult/3b6fd8b83454488b","status":"passed","time":{"start":1736770162387,"stop":1736770187829,"duration":25442}},{"uid":"19e6b166df00a459","reportUrl":"https://golioth.github.io/allure-reports/recurring/64//#testresult/19e6b166df00a459","status":"passed","time":{"start":1736755680247,"stop":1736755705462,"duration":25215}}]},"tags":["linux","anyio","@pytest.mark.usefixtures('anyio_backend')"]},"source":"e4d766cc6c7c928d.json","parameterValues":["'linux'","'linux'"]}