{
  "uid" : "a426da9bb8e7d8a8",
  "name" : "test_cert_provisioning",
  "fullName" : "modules.lib.golioth-firmware-sdk.examples.zephyr.certificate_provisioning.pytest.test_sample#test_cert_provisioning",
  "historyId" : "d3aaa9f3b54361e7a59e70881b33f3cb",
  "time" : {
    "start" : 1734606998546,
    "stop" : 1734606998811,
    "duration" : 265
  },
  "status" : "broken",
  "statusMessage" : "FileNotFoundError: [Errno 2] No such file or directory: 'mcumgr'",
  "statusTrace" : "request = <FixtureRequest for <Function test_cert_provisioning>>\nshell = <twister_harness.helpers.shell.Shell object at 0x7fb3b4efe890>\nproject = <golioth.golioth.Project object at 0x7fb3b5008b80>\ndevice_name = 'certificate-FchhOYXZuAvAJgWL'\nmcumgr_conn_args = ['--conntype=udp', '--connstring=127.0.0.1:1337']\ncertificate_cred = '67640096db61987ad345e6d6', wifi_ssid = None, wifi_psk = None\n\n    async def test_cert_provisioning(request, shell,\n                                     project, device_name,\n                                     mcumgr_conn_args, certificate_cred,\n                                     wifi_ssid, wifi_psk):\n        # Check cloud to verify device does not exist\n    \n        with pytest.raises(Exception):\n            device = await project.device_by_name(device_name)\n    \n        # Generate device certificates\n    \n        subprocess.run([WEST_TOPDIR / \"modules/lib/golioth-firmware-sdk/scripts/certificates/generate_device_certificate.sh\",\n                        project.info['id'], device_name],\n                       cwd=request.config.option.build_dir)\n    \n        # Set WiFi credential\n    \n        if wifi_ssid is not None:\n            shell.exec_command(f\"settings set wifi/ssid \\\"{wifi_ssid}\\\"\")\n    \n        if wifi_psk is not None:\n            shell.exec_command(f\"settings set wifi/psk \\\"{wifi_psk}\\\"\")\n    \n        # Set Golioth credential\n    \n        shell._device.readlines_until(regex=\".*Could not stat /lfs1/credentials/client_cert.der\", timeout=180.0)\n    \n        shell.exec_command('fs mkdir /lfs1/credentials')\n        shell.exec_command('log halt')\n    \n>       result = subprocess.run([\"mcumgr\"] + mcumgr_conn_args +\n                                [\"--tries=3\", \"--timeout=2\",\n                                 \"fs\", \"upload\",\n                                 f\"{project.info['id']}-{device_name}.crt.der\", FS_CRT_PATH],\n                                capture_output=True, text=True,\n                                cwd=request.config.option.build_dir)\n\nmodules/lib/golioth-firmware-sdk/examples/zephyr/certificate_provisioning/pytest/test_sample.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.10/subprocess.py:503: in run\n    with Popen(*popenargs, **kwargs) as process:\n/usr/lib/python3.10/subprocess.py:971: in __init__\n    self._execute_child(args, executable, preexec_fn, close_fds,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Popen: returncode: 255 args: ['mcumgr', '--conntype=udp', '--connstring=127...>\nargs = ['mcumgr', '--conntype=udp', '--connstring=127.0.0.1:1337', '--tries=3', '--timeout=2', 'fs', ...]\nexecutable = b'mcumgr', preexec_fn = None, close_fds = True, pass_fds = ()\ncwd = '/__w/golioth-firmware-sdk/golioth-firmware-sdk/twister-out/native_sim_native/certificate_provisioning/sample.golioth.certificate_provisioning'\nenv = None, startupinfo = None, creationflags = 0, shell = False, p2cread = -1\np2cwrite = -1, c2pread = 13, c2pwrite = 14, errread = 15, errwrite = 16\nrestore_signals = True, gid = None, gids = None, uid = None, umask = -1\nstart_new_session = False\n\n    def _execute_child(self, args, executable, preexec_fn, close_fds,\n                       pass_fds, cwd, env,\n                       startupinfo, creationflags, shell,\n                       p2cread, p2cwrite,\n                       c2pread, c2pwrite,\n                       errread, errwrite,\n                       restore_signals,\n                       gid, gids, uid, umask,\n                       start_new_session):\n        \"\"\"Execute program (POSIX version)\"\"\"\n    \n        if isinstance(args, (str, bytes)):\n            args = [args]\n        elif isinstance(args, os.PathLike):\n            if shell:\n                raise TypeError('path-like args is not allowed when '\n                                'shell is true')\n            args = [args]\n        else:\n            args = list(args)\n    \n        if shell:\n            # On Android the default shell is at '/system/bin/sh'.\n            unix_shell = ('/system/bin/sh' if\n                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')\n            args = [unix_shell, \"-c\"] + args\n            if executable:\n                args[0] = executable\n    \n        if executable is None:\n            executable = args[0]\n    \n        sys.audit(\"subprocess.Popen\", executable, args, cwd, env)\n    \n        if (_USE_POSIX_SPAWN\n                and os.path.dirname(executable)\n                and preexec_fn is None\n                and not close_fds\n                and not pass_fds\n                and cwd is None\n                and (p2cread == -1 or p2cread > 2)\n                and (c2pwrite == -1 or c2pwrite > 2)\n                and (errwrite == -1 or errwrite > 2)\n                and not start_new_session\n                and gid is None\n                and gids is None\n                and uid is None\n                and umask < 0):\n            self._posix_spawn(args, executable, env, restore_signals,\n                              p2cread, p2cwrite,\n                              c2pread, c2pwrite,\n                              errread, errwrite)\n            return\n    \n        orig_executable = executable\n    \n        # For transferring possible exec failure from child to parent.\n        # Data format: \"exception name:hex errno:description\"\n        # Pickle is not used; it is complex and involves memory allocation.\n        errpipe_read, errpipe_write = os.pipe()\n        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.\n        low_fds_to_close = []\n        while errpipe_write < 3:\n            low_fds_to_close.append(errpipe_write)\n            errpipe_write = os.dup(errpipe_write)\n        for low_fd in low_fds_to_close:\n            os.close(low_fd)\n        try:\n            try:\n                # We must avoid complex work that could involve\n                # malloc or free in the child process to avoid\n                # potential deadlocks, thus we do all this here.\n                # and pass it to fork_exec()\n    \n                if env is not None:\n                    env_list = []\n                    for k, v in env.items():\n                        k = os.fsencode(k)\n                        if b'=' in k:\n                            raise ValueError(\"illegal environment variable name\")\n                        env_list.append(k + b'=' + os.fsencode(v))\n                else:\n                    env_list = None  # Use execv instead of execve.\n                executable = os.fsencode(executable)\n                if os.path.dirname(executable):\n                    executable_list = (executable,)\n                else:\n                    # This matches the behavior of os._execvpe().\n                    executable_list = tuple(\n                        os.path.join(os.fsencode(dir), executable)\n                        for dir in os.get_exec_path(env))\n                fds_to_keep = set(pass_fds)\n                fds_to_keep.add(errpipe_write)\n                self.pid = _posixsubprocess.fork_exec(\n                        args, executable_list,\n                        close_fds, tuple(sorted(map(int, fds_to_keep))),\n                        cwd, env_list,\n                        p2cread, p2cwrite, c2pread, c2pwrite,\n                        errread, errwrite,\n                        errpipe_read, errpipe_write,\n                        restore_signals, start_new_session,\n                        gid, gids, uid, umask,\n                        preexec_fn)\n                self._child_created = True\n            finally:\n                # be sure the FD is closed no matter what\n                os.close(errpipe_write)\n    \n            self._close_pipe_fds(p2cread, p2cwrite,\n                                 c2pread, c2pwrite,\n                                 errread, errwrite)\n    \n            # Wait for exec to fail or succeed; possibly raising an\n            # exception (limited in size)\n            errpipe_data = bytearray()\n            while True:\n                part = os.read(errpipe_read, 50000)\n                errpipe_data += part\n                if not part or len(errpipe_data) > 50000:\n                    break\n        finally:\n            # be sure the FD is closed no matter what\n            os.close(errpipe_read)\n    \n        if errpipe_data:\n            try:\n                pid, sts = os.waitpid(self.pid, 0)\n                if pid == self.pid:\n                    self._handle_exitstatus(sts)\n                else:\n                    self.returncode = sys.maxsize\n            except ChildProcessError:\n                pass\n    \n            try:\n                exception_name, hex_errno, err_msg = (\n                        errpipe_data.split(b':', 2))\n                # The encoding here should match the encoding\n                # written in by the subprocess implementations\n                # like _posixsubprocess\n                err_msg = err_msg.decode()\n            except ValueError:\n                exception_name = b'SubprocessError'\n                hex_errno = b'0'\n                err_msg = 'Bad exception data from child: {!r}'.format(\n                              bytes(errpipe_data))\n            child_exception_type = getattr(\n                    builtins, exception_name.decode('ascii'),\n                    SubprocessError)\n            if issubclass(child_exception_type, OSError) and hex_errno:\n                errno_num = int(hex_errno, 16)\n                child_exec_never_called = (err_msg == \"noexec\")\n                if child_exec_never_called:\n                    err_msg = \"\"\n                    # The error must be from chdir(cwd).\n                    err_filename = cwd\n                else:\n                    err_filename = orig_executable\n                if errno_num != 0:\n                    err_msg = os.strerror(errno_num)\n>               raise child_exception_type(errno_num, err_msg, err_filename)\nE               FileNotFoundError: [Errno 2] No such file or directory: 'mcumgr'\n\n/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError",
  "flaky" : false,
  "newFailed" : false,
  "beforeStages" : [ {
    "name" : "dut",
    "time" : {
      "start" : 1734606998535,
      "stop" : 1734606998536,
      "duration" : 1
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "shouldDisplayMessage" : false,
    "hasContent" : false,
    "stepsCount" : 0,
    "attachmentsCount" : 0
  }, {
    "name" : "api_key",
    "time" : {
      "start" : 1734606998016,
      "stop" : 1734606998016,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "shouldDisplayMessage" : false,
    "hasContent" : false,
    "stepsCount" : 0,
    "attachmentsCount" : 0
  }, {
    "name" : "device_object",
    "time" : {
      "start" : 1734606998016,
      "stop" : 1734606998017,
      "duration" : 1
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "shouldDisplayMessage" : false,
    "hasContent" : false,
    "stepsCount" : 0,
    "attachmentsCount" : 0
  }, {
    "name" : "twister_harness_config",
    "time" : {
      "start" : 1734606998016,
      "stop" : 1734606998016,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "shouldDisplayMessage" : false,
    "hasContent" : false,
    "stepsCount" : 0,
    "attachmentsCount" : 0
  }, {
    "name" : "wifi_psk",
    "time" : {
      "start" : 1734606998015,
      "stop" : 1734606998016,
      "duration" : 1
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "shouldDisplayMessage" : false,
    "hasContent" : false,
    "stepsCount" : 0,
    "attachmentsCount" : 0
  }, {
    "name" : "api_url",
    "time" : {
      "start" : 1734606998016,
      "stop" : 1734606998016,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "shouldDisplayMessage" : false,
    "hasContent" : false,
    "stepsCount" : 0,
    "attachmentsCount" : 0
  }, {
    "name" : "wifi_ssid",
    "time" : {
      "start" : 1734606998015,
      "stop" : 1734606998015,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "shouldDisplayMessage" : false,
    "hasContent" : false,
    "stepsCount" : 0,
    "attachmentsCount" : 0
  }, {
    "name" : "device_name",
    "time" : {
      "start" : 1734606998321,
      "stop" : 1734606998322,
      "duration" : 1
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "shouldDisplayMessage" : false,
    "hasContent" : false,
    "stepsCount" : 0,
    "attachmentsCount" : 0
  }, {
    "name" : "project",
    "time" : {
      "start" : 1734606998017,
      "stop" : 1734606998321,
      "duration" : 304
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "shouldDisplayMessage" : false,
    "hasContent" : false,
    "stepsCount" : 0,
    "attachmentsCount" : 0
  }, {
    "name" : "shell",
    "time" : {
      "start" : 1734606998536,
      "stop" : 1734606998545,
      "duration" : 9
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "shouldDisplayMessage" : false,
    "hasContent" : false,
    "stepsCount" : 0,
    "attachmentsCount" : 0
  }, {
    "name" : "certificate_cred",
    "time" : {
      "start" : 1734606998322,
      "stop" : 1734606998534,
      "duration" : 212
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "shouldDisplayMessage" : false,
    "hasContent" : false,
    "stepsCount" : 0,
    "attachmentsCount" : 0
  }, {
    "name" : "mcumgr_conn_args",
    "time" : {
      "start" : 1734606998545,
      "stop" : 1734606998545,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "shouldDisplayMessage" : false,
    "hasContent" : false,
    "stepsCount" : 0,
    "attachmentsCount" : 0
  }, {
    "name" : "anyio_backend",
    "time" : {
      "start" : 1734606998015,
      "stop" : 1734606998015,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "shouldDisplayMessage" : false,
    "hasContent" : false,
    "stepsCount" : 0,
    "attachmentsCount" : 0
  } ],
  "testStage" : {
    "status" : "broken",
    "statusMessage" : "FileNotFoundError: [Errno 2] No such file or directory: 'mcumgr'",
    "statusTrace" : "request = <FixtureRequest for <Function test_cert_provisioning>>\nshell = <twister_harness.helpers.shell.Shell object at 0x7fb3b4efe890>\nproject = <golioth.golioth.Project object at 0x7fb3b5008b80>\ndevice_name = 'certificate-FchhOYXZuAvAJgWL'\nmcumgr_conn_args = ['--conntype=udp', '--connstring=127.0.0.1:1337']\ncertificate_cred = '67640096db61987ad345e6d6', wifi_ssid = None, wifi_psk = None\n\n    async def test_cert_provisioning(request, shell,\n                                     project, device_name,\n                                     mcumgr_conn_args, certificate_cred,\n                                     wifi_ssid, wifi_psk):\n        # Check cloud to verify device does not exist\n    \n        with pytest.raises(Exception):\n            device = await project.device_by_name(device_name)\n    \n        # Generate device certificates\n    \n        subprocess.run([WEST_TOPDIR / \"modules/lib/golioth-firmware-sdk/scripts/certificates/generate_device_certificate.sh\",\n                        project.info['id'], device_name],\n                       cwd=request.config.option.build_dir)\n    \n        # Set WiFi credential\n    \n        if wifi_ssid is not None:\n            shell.exec_command(f\"settings set wifi/ssid \\\"{wifi_ssid}\\\"\")\n    \n        if wifi_psk is not None:\n            shell.exec_command(f\"settings set wifi/psk \\\"{wifi_psk}\\\"\")\n    \n        # Set Golioth credential\n    \n        shell._device.readlines_until(regex=\".*Could not stat /lfs1/credentials/client_cert.der\", timeout=180.0)\n    \n        shell.exec_command('fs mkdir /lfs1/credentials')\n        shell.exec_command('log halt')\n    \n>       result = subprocess.run([\"mcumgr\"] + mcumgr_conn_args +\n                                [\"--tries=3\", \"--timeout=2\",\n                                 \"fs\", \"upload\",\n                                 f\"{project.info['id']}-{device_name}.crt.der\", FS_CRT_PATH],\n                                capture_output=True, text=True,\n                                cwd=request.config.option.build_dir)\n\nmodules/lib/golioth-firmware-sdk/examples/zephyr/certificate_provisioning/pytest/test_sample.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.10/subprocess.py:503: in run\n    with Popen(*popenargs, **kwargs) as process:\n/usr/lib/python3.10/subprocess.py:971: in __init__\n    self._execute_child(args, executable, preexec_fn, close_fds,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Popen: returncode: 255 args: ['mcumgr', '--conntype=udp', '--connstring=127...>\nargs = ['mcumgr', '--conntype=udp', '--connstring=127.0.0.1:1337', '--tries=3', '--timeout=2', 'fs', ...]\nexecutable = b'mcumgr', preexec_fn = None, close_fds = True, pass_fds = ()\ncwd = '/__w/golioth-firmware-sdk/golioth-firmware-sdk/twister-out/native_sim_native/certificate_provisioning/sample.golioth.certificate_provisioning'\nenv = None, startupinfo = None, creationflags = 0, shell = False, p2cread = -1\np2cwrite = -1, c2pread = 13, c2pwrite = 14, errread = 15, errwrite = 16\nrestore_signals = True, gid = None, gids = None, uid = None, umask = -1\nstart_new_session = False\n\n    def _execute_child(self, args, executable, preexec_fn, close_fds,\n                       pass_fds, cwd, env,\n                       startupinfo, creationflags, shell,\n                       p2cread, p2cwrite,\n                       c2pread, c2pwrite,\n                       errread, errwrite,\n                       restore_signals,\n                       gid, gids, uid, umask,\n                       start_new_session):\n        \"\"\"Execute program (POSIX version)\"\"\"\n    \n        if isinstance(args, (str, bytes)):\n            args = [args]\n        elif isinstance(args, os.PathLike):\n            if shell:\n                raise TypeError('path-like args is not allowed when '\n                                'shell is true')\n            args = [args]\n        else:\n            args = list(args)\n    \n        if shell:\n            # On Android the default shell is at '/system/bin/sh'.\n            unix_shell = ('/system/bin/sh' if\n                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')\n            args = [unix_shell, \"-c\"] + args\n            if executable:\n                args[0] = executable\n    \n        if executable is None:\n            executable = args[0]\n    \n        sys.audit(\"subprocess.Popen\", executable, args, cwd, env)\n    \n        if (_USE_POSIX_SPAWN\n                and os.path.dirname(executable)\n                and preexec_fn is None\n                and not close_fds\n                and not pass_fds\n                and cwd is None\n                and (p2cread == -1 or p2cread > 2)\n                and (c2pwrite == -1 or c2pwrite > 2)\n                and (errwrite == -1 or errwrite > 2)\n                and not start_new_session\n                and gid is None\n                and gids is None\n                and uid is None\n                and umask < 0):\n            self._posix_spawn(args, executable, env, restore_signals,\n                              p2cread, p2cwrite,\n                              c2pread, c2pwrite,\n                              errread, errwrite)\n            return\n    \n        orig_executable = executable\n    \n        # For transferring possible exec failure from child to parent.\n        # Data format: \"exception name:hex errno:description\"\n        # Pickle is not used; it is complex and involves memory allocation.\n        errpipe_read, errpipe_write = os.pipe()\n        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.\n        low_fds_to_close = []\n        while errpipe_write < 3:\n            low_fds_to_close.append(errpipe_write)\n            errpipe_write = os.dup(errpipe_write)\n        for low_fd in low_fds_to_close:\n            os.close(low_fd)\n        try:\n            try:\n                # We must avoid complex work that could involve\n                # malloc or free in the child process to avoid\n                # potential deadlocks, thus we do all this here.\n                # and pass it to fork_exec()\n    \n                if env is not None:\n                    env_list = []\n                    for k, v in env.items():\n                        k = os.fsencode(k)\n                        if b'=' in k:\n                            raise ValueError(\"illegal environment variable name\")\n                        env_list.append(k + b'=' + os.fsencode(v))\n                else:\n                    env_list = None  # Use execv instead of execve.\n                executable = os.fsencode(executable)\n                if os.path.dirname(executable):\n                    executable_list = (executable,)\n                else:\n                    # This matches the behavior of os._execvpe().\n                    executable_list = tuple(\n                        os.path.join(os.fsencode(dir), executable)\n                        for dir in os.get_exec_path(env))\n                fds_to_keep = set(pass_fds)\n                fds_to_keep.add(errpipe_write)\n                self.pid = _posixsubprocess.fork_exec(\n                        args, executable_list,\n                        close_fds, tuple(sorted(map(int, fds_to_keep))),\n                        cwd, env_list,\n                        p2cread, p2cwrite, c2pread, c2pwrite,\n                        errread, errwrite,\n                        errpipe_read, errpipe_write,\n                        restore_signals, start_new_session,\n                        gid, gids, uid, umask,\n                        preexec_fn)\n                self._child_created = True\n            finally:\n                # be sure the FD is closed no matter what\n                os.close(errpipe_write)\n    \n            self._close_pipe_fds(p2cread, p2cwrite,\n                                 c2pread, c2pwrite,\n                                 errread, errwrite)\n    \n            # Wait for exec to fail or succeed; possibly raising an\n            # exception (limited in size)\n            errpipe_data = bytearray()\n            while True:\n                part = os.read(errpipe_read, 50000)\n                errpipe_data += part\n                if not part or len(errpipe_data) > 50000:\n                    break\n        finally:\n            # be sure the FD is closed no matter what\n            os.close(errpipe_read)\n    \n        if errpipe_data:\n            try:\n                pid, sts = os.waitpid(self.pid, 0)\n                if pid == self.pid:\n                    self._handle_exitstatus(sts)\n                else:\n                    self.returncode = sys.maxsize\n            except ChildProcessError:\n                pass\n    \n            try:\n                exception_name, hex_errno, err_msg = (\n                        errpipe_data.split(b':', 2))\n                # The encoding here should match the encoding\n                # written in by the subprocess implementations\n                # like _posixsubprocess\n                err_msg = err_msg.decode()\n            except ValueError:\n                exception_name = b'SubprocessError'\n                hex_errno = b'0'\n                err_msg = 'Bad exception data from child: {!r}'.format(\n                              bytes(errpipe_data))\n            child_exception_type = getattr(\n                    builtins, exception_name.decode('ascii'),\n                    SubprocessError)\n            if issubclass(child_exception_type, OSError) and hex_errno:\n                errno_num = int(hex_errno, 16)\n                child_exec_never_called = (err_msg == \"noexec\")\n                if child_exec_never_called:\n                    err_msg = \"\"\n                    # The error must be from chdir(cwd).\n                    err_filename = cwd\n                else:\n                    err_filename = orig_executable\n                if errno_num != 0:\n                    err_msg = os.strerror(errno_num)\n>               raise child_exception_type(errno_num, err_msg, err_filename)\nE               FileNotFoundError: [Errno 2] No such file or directory: 'mcumgr'\n\n/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError",
    "steps" : [ ],
    "attachments" : [ {
      "uid" : "368761e8241ef85f",
      "name" : "log",
      "source" : "368761e8241ef85f.txt",
      "type" : "text/plain",
      "size" : 13980
    } ],
    "parameters" : [ ],
    "shouldDisplayMessage" : true,
    "hasContent" : true,
    "stepsCount" : 0,
    "attachmentsCount" : 1
  },
  "afterStages" : [ {
    "name" : "dut::0",
    "time" : {
      "start" : 1734606998928,
      "stop" : 1734606999444,
      "duration" : 516
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "shouldDisplayMessage" : false,
    "hasContent" : false,
    "stepsCount" : 0,
    "attachmentsCount" : 0
  }, {
    "name" : "device_object::0",
    "time" : {
      "start" : 1734606999830,
      "stop" : 1734606999830,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "shouldDisplayMessage" : false,
    "hasContent" : false,
    "stepsCount" : 0,
    "attachmentsCount" : 0
  }, {
    "name" : "device_name::0",
    "time" : {
      "start" : 1734606999641,
      "stop" : 1734606999829,
      "duration" : 188
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "shouldDisplayMessage" : false,
    "hasContent" : false,
    "stepsCount" : 0,
    "attachmentsCount" : 0
  }, {
    "name" : "project::0",
    "time" : {
      "start" : 1734606999829,
      "stop" : 1734606999830,
      "duration" : 1
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "shouldDisplayMessage" : false,
    "hasContent" : false,
    "stepsCount" : 0,
    "attachmentsCount" : 0
  }, {
    "name" : "certificate_cred::0",
    "time" : {
      "start" : 1734606999445,
      "stop" : 1734606999640,
      "duration" : 195
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "shouldDisplayMessage" : false,
    "hasContent" : false,
    "stepsCount" : 0,
    "attachmentsCount" : 0
  } ],
  "labels" : [ {
    "name" : "tag",
    "value" : "native_sim_32"
  }, {
    "name" : "tag",
    "value" : "zephyr"
  }, {
    "name" : "parentSuite",
    "value" : "sample.zephyr.native_sim_32"
  }, {
    "name" : "tag",
    "value" : "GitHub Actions 53"
  }, {
    "name" : "tag",
    "value" : "@pytest.mark.usefixtures('anyio_backend')"
  }, {
    "name" : "tag",
    "value" : "anyio"
  }, {
    "name" : "suite",
    "value" : "test_sample"
  }, {
    "name" : "host",
    "value" : "d901d0241497"
  }, {
    "name" : "thread",
    "value" : "43346-MainThread"
  }, {
    "name" : "framework",
    "value" : "pytest"
  }, {
    "name" : "language",
    "value" : "cpython3"
  }, {
    "name" : "package",
    "value" : "modules.lib.golioth-firmware-sdk.examples.zephyr.certificate_provisioning.pytest.test_sample"
  }, {
    "name" : "resultFormat",
    "value" : "allure2"
  } ],
  "parameters" : [ {
    "name" : "board_name",
    "value" : "'native_sim_32'"
  }, {
    "name" : "platform_name",
    "value" : "'zephyr'"
  } ],
  "links" : [ ],
  "hidden" : false,
  "retry" : false,
  "extra" : {
    "severity" : "normal",
    "retries" : [ ],
    "categories" : [ {
      "name" : "Test defects",
      "matchedStatuses" : [ ],
      "flaky" : false
    } ],
    "history" : {
      "statistic" : {
        "failed" : 0,
        "broken" : 2,
        "skipped" : 0,
        "passed" : 33,
        "unknown" : 0,
        "total" : 35
      },
      "items" : [ {
        "uid" : "1e89def35d4fa619",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1958/#testresult/1e89def35d4fa619",
        "status" : "passed",
        "time" : {
          "start" : 1734587460304,
          "stop" : 1734587477095,
          "duration" : 16791
        }
      }, {
        "uid" : "e245ec3084f7acf5",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1956/#testresult/e245ec3084f7acf5",
        "status" : "passed",
        "time" : {
          "start" : 1734554294601,
          "stop" : 1734554311566,
          "duration" : 16965
        }
      }, {
        "uid" : "4b0f815e7565b1e",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1954/#testresult/4b0f815e7565b1e",
        "status" : "passed",
        "time" : {
          "start" : 1734551149445,
          "stop" : 1734551166507,
          "duration" : 17062
        }
      }, {
        "uid" : "2ad6a014a1cceca2",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1952/#testresult/2ad6a014a1cceca2",
        "status" : "passed",
        "time" : {
          "start" : 1734534329570,
          "stop" : 1734534346269,
          "duration" : 16699
        }
      }, {
        "uid" : "63b2b86656157ae1",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1948/#testresult/63b2b86656157ae1",
        "status" : "passed",
        "time" : {
          "start" : 1734455393425,
          "stop" : 1734455410679,
          "duration" : 17254
        }
      }, {
        "uid" : "f702aedd05dc320f",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1948/#testresult/f702aedd05dc320f",
        "status" : "passed",
        "time" : {
          "start" : 1734455393425,
          "stop" : 1734455410679,
          "duration" : 17254
        }
      }, {
        "uid" : "cbd7142037b0510",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1948/#testresult/cbd7142037b0510",
        "status" : "passed",
        "time" : {
          "start" : 1734455393425,
          "stop" : 1734455410679,
          "duration" : 17254
        }
      }, {
        "uid" : "4015265d4fb7b165",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1947/#testresult/4015265d4fb7b165",
        "status" : "passed",
        "time" : {
          "start" : 1734450032019,
          "stop" : 1734450048957,
          "duration" : 16938
        }
      }, {
        "uid" : "3d64e1e5d49a8e64",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1945/#testresult/3d64e1e5d49a8e64",
        "status" : "passed",
        "time" : {
          "start" : 1734441450998,
          "stop" : 1734441467805,
          "duration" : 16807
        }
      }, {
        "uid" : "3869ae6c9430c211",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1943/#testresult/3869ae6c9430c211",
        "status" : "passed",
        "time" : {
          "start" : 1734376394987,
          "stop" : 1734376411932,
          "duration" : 16945
        }
      }, {
        "uid" : "55303cadb05f03ef",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1943/#testresult/55303cadb05f03ef",
        "status" : "passed",
        "time" : {
          "start" : 1734376394987,
          "stop" : 1734376411932,
          "duration" : 16945
        }
      }, {
        "uid" : "79288968c79d8e60",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/41/#testresult/79288968c79d8e60",
        "status" : "broken",
        "statusDetails" : "twister_harness.exceptions.TwisterHarnessException: No connection to the device and no more data to read.",
        "time" : {
          "start" : 1734236930691,
          "stop" : 1734236936915,
          "duration" : 6224
        }
      }, {
        "uid" : "f7795d08b2c2b229",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1931/#testresult/f7795d08b2c2b229",
        "status" : "passed",
        "time" : {
          "start" : 1734125987628,
          "stop" : 1734126004607,
          "duration" : 16979
        }
      }, {
        "uid" : "6c1e585e614d7fad",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1928/#testresult/6c1e585e614d7fad",
        "status" : "passed",
        "time" : {
          "start" : 1734043578117,
          "stop" : 1734043594948,
          "duration" : 16831
        }
      }, {
        "uid" : "2326184ed95797e0",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1927/#testresult/2326184ed95797e0",
        "status" : "passed",
        "time" : {
          "start" : 1734042621549,
          "stop" : 1734042638312,
          "duration" : 16763
        }
      }, {
        "uid" : "e4ea21bb8a3e71d9",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1921/#testresult/e4ea21bb8a3e71d9",
        "status" : "passed",
        "time" : {
          "start" : 1734022427894,
          "stop" : 1734022444870,
          "duration" : 16976
        }
      }, {
        "uid" : "e56cb046b624f34b",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1914/#testresult/e56cb046b624f34b",
        "status" : "passed",
        "time" : {
          "start" : 1734017121351,
          "stop" : 1734017138075,
          "duration" : 16724
        }
      }, {
        "uid" : "490c456210ce8bc",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1913/#testresult/490c456210ce8bc",
        "status" : "passed",
        "time" : {
          "start" : 1734016907920,
          "stop" : 1734016924726,
          "duration" : 16806
        }
      }, {
        "uid" : "3759377ffa16cdae",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1897/#testresult/3759377ffa16cdae",
        "status" : "passed",
        "time" : {
          "start" : 1733937004355,
          "stop" : 1733937021126,
          "duration" : 16771
        }
      }, {
        "uid" : "6a156fd00d2940e7",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1908/#testresult/6a156fd00d2940e7",
        "status" : "passed",
        "time" : {
          "start" : 1733958030764,
          "stop" : 1733958047609,
          "duration" : 16845
        }
      } ]
    },
    "tags" : [ "anyio", "native_sim_32", "GitHub Actions 53", "@pytest.mark.usefixtures('anyio_backend')", "zephyr" ]
  },
  "source" : "a426da9bb8e7d8a8.json",
  "parameterValues" : [ "'native_sim_32'", "'zephyr'" ]
}