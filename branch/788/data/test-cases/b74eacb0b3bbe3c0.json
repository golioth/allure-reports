{"uid":"b74eacb0b3bbe3c0","name":"test_fw_update","fullName":"examples.esp_idf.fw_update.pytest.test_sample#test_fw_update","historyId":"48d0816a206ae6718f292d04b6749e18","time":{"start":1761065074099,"stop":1761065641302,"duration":567203},"status":"failed","statusMessage":"Failed: Timeout (>600.0s) from pytest-timeout.","statusTrace":"pyfuncitem = <Function test_fw_update>\n\n    @pytest.hookimpl(tryfirst=True)\n    def pytest_pyfunc_call(pyfuncitem: Any) -> bool | None:\n        def run_with_hypothesis(**kwargs: Any) -> None:\n            with get_runner(backend_name, backend_options) as runner:\n                runner.run_test(original_func, kwargs)\n    \n        backend = pyfuncitem.funcargs.get(\"anyio_backend\")\n        if backend:\n            backend_name, backend_options = extract_backend_and_options(backend)\n    \n            if hasattr(pyfuncitem.obj, \"hypothesis\"):\n                # Wrap the inner test function unless it's already wrapped\n                original_func = pyfuncitem.obj.hypothesis.inner_test\n                if original_func.__qualname__ != run_with_hypothesis.__qualname__:\n                    if iscoroutinefunction(original_func):\n                        pyfuncitem.obj.hypothesis.inner_test = run_with_hypothesis\n    \n                return None\n    \n            if iscoroutinefunction(pyfuncitem.obj):\n                funcargs = pyfuncitem.funcargs\n                testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n                with get_runner(backend_name, backend_options) as runner:\n                    try:\n>                       runner.run_test(pyfuncitem.obj, testargs)\n\n/root/venv/lib/python3.13/site-packages/anyio/pytest_plugin.py:186: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/root/venv/lib/python3.13/site-packages/anyio/_backends/_trio.py:972: in run_test\n    self._call_in_runner_task(test_func, **kwargs)\n/root/venv/lib/python3.13/site-packages/anyio/_backends/_trio.py:940: in _call_in_runner_task\n    self._call_queue.get()()\n    ^^^^^^^^^^^^^^^^^^^^^^\n/usr/cpython-3.13.9-linux-aarch64-gnu/lib/python3.13/queue.py:199: in get\n    self.not_empty.wait()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Condition(<unlocked _thread.lock object at 0xffff8f565750>, 0)>\ntimeout = None\n\n    def wait(self, timeout=None):\n        \"\"\"Wait until notified or until a timeout occurs.\n    \n        If the calling thread has not acquired the lock when this method is\n        called, a RuntimeError is raised.\n    \n        This method releases the underlying lock, and then blocks until it is\n        awakened by a notify() or notify_all() call for the same condition\n        variable in another thread, or until the optional timeout occurs. Once\n        awakened or timed out, it re-acquires the lock and returns.\n    \n        When the timeout argument is present and not None, it should be a\n        floating-point number specifying a timeout for the operation in seconds\n        (or fractions thereof).\n    \n        When the underlying lock is an RLock, it is not released using its\n        release() method, since this may not actually unlock the lock when it\n        was acquired multiple times recursively. Instead, an internal interface\n        of the RLock class is used, which really unlocks it even when it has\n        been recursively acquired several times. Another internal interface is\n        then used to restore the recursion level when the lock is reacquired.\n    \n        \"\"\"\n        if not self._is_owned():\n            raise RuntimeError(\"cannot wait on un-acquired lock\")\n        waiter = _allocate_lock()\n        waiter.acquire()\n        self._waiters.append(waiter)\n        saved_state = self._release_save()\n        gotit = False\n        try:    # restore state no matter what (e.g., KeyboardInterrupt)\n            if timeout is None:\n>               waiter.acquire()\nE               Failed: Timeout (>600.0s) from pytest-timeout.\n\n/usr/cpython-3.13.9-linux-aarch64-gnu/lib/python3.13/threading.py:359: Failed","flaky":false,"newFailed":true,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"anyio_backend","time":{"start":1761065041282,"stop":1761065041283,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"fw_info","time":{"start":1761065041283,"stop":1761065041315,"duration":32},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"baud","time":{"start":1761065041316,"stop":1761065041316,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"api_key","time":{"start":1761065041317,"stop":1761065041318,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"wifi_psk","time":{"start":1761065041317,"stop":1761065041317,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"wifi_ssid","time":{"start":1761065041317,"stop":1761065041317,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"device_name","time":{"start":1761065041318,"stop":1761065041319,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"api_url","time":{"start":1761065041318,"stop":1761065041318,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"blueprint_name","time":{"start":1761065041319,"stop":1761065041319,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"board","time":{"start":1761065041319,"stop":1761065070982,"duration":29663},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"board_name","time":{"start":1761065041320,"stop":1761065041320,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"fw_image","time":{"start":1761065041321,"stop":1761065041321,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"serial_number","time":{"start":1761065041321,"stop":1761065041322,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"port","time":{"start":1761065041321,"stop":1761065041321,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"bmp_port","time":{"start":1761065041322,"stop":1761065041322,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"project","time":{"start":1761065070983,"stop":1761065071417,"duration":434},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"device","time":{"start":1761065071418,"stop":1761065072026,"duration":608},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"blueprint_id","time":{"start":1761065072027,"stop":1761065072340,"duration":313},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"artifact","time":{"start":1761065072340,"stop":1761065072642,"duration":302},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"tag","time":{"start":1761065072643,"stop":1761065073704,"duration":1061},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"release","time":{"start":1761065073705,"stop":1761065074096,"duration":391},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"testStage":{"status":"failed","statusMessage":"Failed: Timeout (>600.0s) from pytest-timeout.","statusTrace":"pyfuncitem = <Function test_fw_update>\n\n    @pytest.hookimpl(tryfirst=True)\n    def pytest_pyfunc_call(pyfuncitem: Any) -> bool | None:\n        def run_with_hypothesis(**kwargs: Any) -> None:\n            with get_runner(backend_name, backend_options) as runner:\n                runner.run_test(original_func, kwargs)\n    \n        backend = pyfuncitem.funcargs.get(\"anyio_backend\")\n        if backend:\n            backend_name, backend_options = extract_backend_and_options(backend)\n    \n            if hasattr(pyfuncitem.obj, \"hypothesis\"):\n                # Wrap the inner test function unless it's already wrapped\n                original_func = pyfuncitem.obj.hypothesis.inner_test\n                if original_func.__qualname__ != run_with_hypothesis.__qualname__:\n                    if iscoroutinefunction(original_func):\n                        pyfuncitem.obj.hypothesis.inner_test = run_with_hypothesis\n    \n                return None\n    \n            if iscoroutinefunction(pyfuncitem.obj):\n                funcargs = pyfuncitem.funcargs\n                testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n                with get_runner(backend_name, backend_options) as runner:\n                    try:\n>                       runner.run_test(pyfuncitem.obj, testargs)\n\n/root/venv/lib/python3.13/site-packages/anyio/pytest_plugin.py:186: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/root/venv/lib/python3.13/site-packages/anyio/_backends/_trio.py:972: in run_test\n    self._call_in_runner_task(test_func, **kwargs)\n/root/venv/lib/python3.13/site-packages/anyio/_backends/_trio.py:940: in _call_in_runner_task\n    self._call_queue.get()()\n    ^^^^^^^^^^^^^^^^^^^^^^\n/usr/cpython-3.13.9-linux-aarch64-gnu/lib/python3.13/queue.py:199: in get\n    self.not_empty.wait()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Condition(<unlocked _thread.lock object at 0xffff8f565750>, 0)>\ntimeout = None\n\n    def wait(self, timeout=None):\n        \"\"\"Wait until notified or until a timeout occurs.\n    \n        If the calling thread has not acquired the lock when this method is\n        called, a RuntimeError is raised.\n    \n        This method releases the underlying lock, and then blocks until it is\n        awakened by a notify() or notify_all() call for the same condition\n        variable in another thread, or until the optional timeout occurs. Once\n        awakened or timed out, it re-acquires the lock and returns.\n    \n        When the timeout argument is present and not None, it should be a\n        floating-point number specifying a timeout for the operation in seconds\n        (or fractions thereof).\n    \n        When the underlying lock is an RLock, it is not released using its\n        release() method, since this may not actually unlock the lock when it\n        was acquired multiple times recursively. Instead, an internal interface\n        of the RLock class is used, which really unlocks it even when it has\n        been recursively acquired several times. Another internal interface is\n        then used to restore the recursion level when the lock is reacquired.\n    \n        \"\"\"\n        if not self._is_owned():\n            raise RuntimeError(\"cannot wait on un-acquired lock\")\n        waiter = _allocate_lock()\n        waiter.acquire()\n        self._waiters.append(waiter)\n        saved_state = self._release_save()\n        gotit = False\n        try:    # restore state no matter what (e.g., KeyboardInterrupt)\n            if timeout is None:\n>               waiter.acquire()\nE               Failed: Timeout (>600.0s) from pytest-timeout.\n\n/usr/cpython-3.13.9-linux-aarch64-gnu/lib/python3.13/threading.py:359: Failed","steps":[],"attachments":[{"uid":"b6207c70b9db7336","name":"stdout","source":"b6207c70b9db7336.txt","type":"text/plain","size":71231}],"parameters":[],"shouldDisplayMessage":true,"stepsCount":0,"attachmentsCount":1,"hasContent":true,"attachmentStep":false},"afterStages":[{"name":"release::0","time":{"start":1761065641822,"stop":1761065685244,"duration":43422},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"tag::0","time":{"start":1761065685246,"stop":1761065685919,"duration":673},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"artifact::0","time":{"start":1761065685921,"stop":1761065685922,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"blueprint_id::0","time":{"start":1761065685924,"stop":1761065685924,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"device::0","time":{"start":1761065685926,"stop":1761065686235,"duration":309},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"project::0","time":{"start":1761065686237,"stop":1761065686237,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"board::0","time":{"start":1761065686239,"stop":1761065686247,"duration":8},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"fw_info::0","time":{"start":1761065686264,"stop":1761065686266,"duration":2},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"labels":[{"name":"tag","value":"esp32s3_devkitc_espidf"},{"name":"tag","value":"esp-idf"},{"name":"parentSuite","value":"sample.esp-idf.esp32s3_devkitc_espidf"},{"name":"tag","value":"jons_orange_pi"},{"name":"tag","value":"anyio"},{"name":"suite","value":"test_sample"},{"name":"host","value":"913e76ae07c5"},{"name":"thread","value":"278-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"examples.esp_idf.fw_update.pytest.test_sample"},{"name":"resultFormat","value":"allure2"}],"parameters":[{"name":"board_name","value":"'esp32s3_devkitc_espidf'"},{"name":"platform_name","value":"'esp-idf'"}],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Product defects","matchedStatuses":[],"flaky":false}],"history":{"statistic":{"failed":1,"broken":0,"skipped":0,"passed":3,"unknown":0,"total":4},"items":[{"uid":"dd98f7a162666925","reportUrl":"https://golioth.github.io/allure-reports/branch/787//#testresult/dd98f7a162666925","status":"passed","time":{"start":1761056507282,"stop":1761056741486,"duration":234204}},{"uid":"6da1ef53184fbfd7","reportUrl":"https://golioth.github.io/allure-reports/branch/784//#testresult/6da1ef53184fbfd7","status":"passed","time":{"start":1760994610177,"stop":1760994831658,"duration":221481}},{"uid":"4ec0970077a68da3","reportUrl":"https://golioth.github.io/allure-reports/branch/783//#testresult/4ec0970077a68da3","status":"passed","time":{"start":1760991862541,"stop":1760992051449,"duration":188908}}]},"tags":["esp32s3_devkitc_espidf","esp-idf","jons_orange_pi","anyio"]},"source":"b74eacb0b3bbe3c0.json","parameterValues":["'esp32s3_devkitc_espidf'","'esp-idf'"]}