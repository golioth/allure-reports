{
  "uid" : "cf257291e6f5e283",
  "name" : "test_fw_update",
  "fullName" : "examples.esp_idf.fw_update.pytest.test_sample#test_fw_update",
  "historyId" : "48c502b7c3a18589bd5b8c82c76807ee",
  "time" : {
    "start" : 1733453423642,
    "stop" : 1733453992930,
    "duration" : 569288
  },
  "status" : "failed",
  "statusMessage" : "Failed: Timeout >600.0s",
  "statusTrace" : "pyfuncitem = <Function test_fw_update>\n\n    @pytest.hookimpl(tryfirst=True)\n    def pytest_pyfunc_call(pyfuncitem: Any) -> bool | None:\n        def run_with_hypothesis(**kwargs: Any) -> None:\n            with get_runner(backend_name, backend_options) as runner:\n                runner.run_test(original_func, kwargs)\n    \n        backend = pyfuncitem.funcargs.get(\"anyio_backend\")\n        if backend:\n            backend_name, backend_options = extract_backend_and_options(backend)\n    \n            if hasattr(pyfuncitem.obj, \"hypothesis\"):\n                # Wrap the inner test function unless it's already wrapped\n                original_func = pyfuncitem.obj.hypothesis.inner_test\n                if original_func.__qualname__ != run_with_hypothesis.__qualname__:\n                    if iscoroutinefunction(original_func):\n                        pyfuncitem.obj.hypothesis.inner_test = run_with_hypothesis\n    \n                return None\n    \n            if iscoroutinefunction(pyfuncitem.obj):\n                funcargs = pyfuncitem.funcargs\n                testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n                with get_runner(backend_name, backend_options) as runner:\n                    try:\n>                       runner.run_test(pyfuncitem.obj, testargs)\n\n/usr/local/lib/python3.11/dist-packages/anyio/pytest_plugin.py:131: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.11/dist-packages/anyio/_backends/_trio.py:951: in run_test\n    self._call_in_runner_task(test_func, **kwargs)\n/usr/local/lib/python3.11/dist-packages/anyio/_backends/_trio.py:919: in _call_in_runner_task\n    self._call_queue.get()()\n/usr/lib/python3.11/queue.py:171: in get\n    self.not_empty.wait()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Condition(<unlocked _thread.lock object at 0xffff8093edc0>, 0)>\ntimeout = None\n\n    def wait(self, timeout=None):\n        \"\"\"Wait until notified or until a timeout occurs.\n    \n        If the calling thread has not acquired the lock when this method is\n        called, a RuntimeError is raised.\n    \n        This method releases the underlying lock, and then blocks until it is\n        awakened by a notify() or notify_all() call for the same condition\n        variable in another thread, or until the optional timeout occurs. Once\n        awakened or timed out, it re-acquires the lock and returns.\n    \n        When the timeout argument is present and not None, it should be a\n        floating point number specifying a timeout for the operation in seconds\n        (or fractions thereof).\n    \n        When the underlying lock is an RLock, it is not released using its\n        release() method, since this may not actually unlock the lock when it\n        was acquired multiple times recursively. Instead, an internal interface\n        of the RLock class is used, which really unlocks it even when it has\n        been recursively acquired several times. Another internal interface is\n        then used to restore the recursion level when the lock is reacquired.\n    \n        \"\"\"\n        if not self._is_owned():\n            raise RuntimeError(\"cannot wait on un-acquired lock\")\n        waiter = _allocate_lock()\n        waiter.acquire()\n        self._waiters.append(waiter)\n        saved_state = self._release_save()\n        gotit = False\n        try:    # restore state no matter what (e.g., KeyboardInterrupt)\n            if timeout is None:\n>               waiter.acquire()\nE               Failed: Timeout >600.0s\n\n/usr/lib/python3.11/threading.py:320: Failed",
  "flaky" : false,
  "newFailed" : true,
  "beforeStages" : [ {
    "name" : "blueprint_name",
    "time" : {
      "start" : 1733453392953,
      "stop" : 1733453392953,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "blueprint_id",
    "time" : {
      "start" : 1733453420541,
      "stop" : 1733453420919,
      "duration" : 378
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "device",
    "time" : {
      "start" : 1733453419298,
      "stop" : 1733453420540,
      "duration" : 1242
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "fw_info",
    "time" : {
      "start" : 1733453392909,
      "stop" : 1733453392937,
      "duration" : 28
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "tag",
    "time" : {
      "start" : 1733453421350,
      "stop" : 1733453423256,
      "duration" : 1906
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "artifact",
    "time" : {
      "start" : 1733453420920,
      "stop" : 1733453421349,
      "duration" : 429
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "wifi_ssid",
    "time" : {
      "start" : 1733453392940,
      "stop" : 1733453392940,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "release",
    "time" : {
      "start" : 1733453423256,
      "stop" : 1733453423639,
      "duration" : 383
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "board",
    "time" : {
      "start" : 1733453392953,
      "stop" : 1733453418809,
      "duration" : 25856
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "device_name",
    "time" : {
      "start" : 1733453392952,
      "stop" : 1733453392952,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "api_key",
    "time" : {
      "start" : 1733453392951,
      "stop" : 1733453392951,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "wifi_psk",
    "time" : {
      "start" : 1733453392940,
      "stop" : 1733453392940,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "serial_number",
    "time" : {
      "start" : 1733453392941,
      "stop" : 1733453392941,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "project",
    "time" : {
      "start" : 1733453418810,
      "stop" : 1733453419297,
      "duration" : 487
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "baud",
    "time" : {
      "start" : 1733453392939,
      "stop" : 1733453392939,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "anyio_backend",
    "time" : {
      "start" : 1733453392908,
      "stop" : 1733453392908,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "bmp_port",
    "time" : {
      "start" : 1733453392941,
      "stop" : 1733453392942,
      "duration" : 1
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "api_url",
    "time" : {
      "start" : 1733453392952,
      "stop" : 1733453392952,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "port",
    "time" : {
      "start" : 1733453392938,
      "stop" : 1733453392939,
      "duration" : 1
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "board_name",
    "time" : {
      "start" : 1733453392938,
      "stop" : 1733453392938,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "fw_image",
    "time" : {
      "start" : 1733453392941,
      "stop" : 1733453392941,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  } ],
  "testStage" : {
    "status" : "failed",
    "statusMessage" : "Failed: Timeout >600.0s",
    "statusTrace" : "pyfuncitem = <Function test_fw_update>\n\n    @pytest.hookimpl(tryfirst=True)\n    def pytest_pyfunc_call(pyfuncitem: Any) -> bool | None:\n        def run_with_hypothesis(**kwargs: Any) -> None:\n            with get_runner(backend_name, backend_options) as runner:\n                runner.run_test(original_func, kwargs)\n    \n        backend = pyfuncitem.funcargs.get(\"anyio_backend\")\n        if backend:\n            backend_name, backend_options = extract_backend_and_options(backend)\n    \n            if hasattr(pyfuncitem.obj, \"hypothesis\"):\n                # Wrap the inner test function unless it's already wrapped\n                original_func = pyfuncitem.obj.hypothesis.inner_test\n                if original_func.__qualname__ != run_with_hypothesis.__qualname__:\n                    if iscoroutinefunction(original_func):\n                        pyfuncitem.obj.hypothesis.inner_test = run_with_hypothesis\n    \n                return None\n    \n            if iscoroutinefunction(pyfuncitem.obj):\n                funcargs = pyfuncitem.funcargs\n                testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n                with get_runner(backend_name, backend_options) as runner:\n                    try:\n>                       runner.run_test(pyfuncitem.obj, testargs)\n\n/usr/local/lib/python3.11/dist-packages/anyio/pytest_plugin.py:131: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.11/dist-packages/anyio/_backends/_trio.py:951: in run_test\n    self._call_in_runner_task(test_func, **kwargs)\n/usr/local/lib/python3.11/dist-packages/anyio/_backends/_trio.py:919: in _call_in_runner_task\n    self._call_queue.get()()\n/usr/lib/python3.11/queue.py:171: in get\n    self.not_empty.wait()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Condition(<unlocked _thread.lock object at 0xffff8093edc0>, 0)>\ntimeout = None\n\n    def wait(self, timeout=None):\n        \"\"\"Wait until notified or until a timeout occurs.\n    \n        If the calling thread has not acquired the lock when this method is\n        called, a RuntimeError is raised.\n    \n        This method releases the underlying lock, and then blocks until it is\n        awakened by a notify() or notify_all() call for the same condition\n        variable in another thread, or until the optional timeout occurs. Once\n        awakened or timed out, it re-acquires the lock and returns.\n    \n        When the timeout argument is present and not None, it should be a\n        floating point number specifying a timeout for the operation in seconds\n        (or fractions thereof).\n    \n        When the underlying lock is an RLock, it is not released using its\n        release() method, since this may not actually unlock the lock when it\n        was acquired multiple times recursively. Instead, an internal interface\n        of the RLock class is used, which really unlocks it even when it has\n        been recursively acquired several times. Another internal interface is\n        then used to restore the recursion level when the lock is reacquired.\n    \n        \"\"\"\n        if not self._is_owned():\n            raise RuntimeError(\"cannot wait on un-acquired lock\")\n        waiter = _allocate_lock()\n        waiter.acquire()\n        self._waiters.append(waiter)\n        saved_state = self._release_save()\n        gotit = False\n        try:    # restore state no matter what (e.g., KeyboardInterrupt)\n            if timeout is None:\n>               waiter.acquire()\nE               Failed: Timeout >600.0s\n\n/usr/lib/python3.11/threading.py:320: Failed",
    "steps" : [ ],
    "attachments" : [ {
      "uid" : "5797c44bfb98a993",
      "name" : "stdout",
      "source" : "5797c44bfb98a993.txt",
      "type" : "text/plain",
      "size" : 89133
    } ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 1,
    "shouldDisplayMessage" : true,
    "hasContent" : true
  },
  "afterStages" : [ {
    "name" : "blueprint_id::0",
    "time" : {
      "start" : 1733454031479,
      "stop" : 1733454031479,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "device::0",
    "time" : {
      "start" : 1733454031481,
      "stop" : 1733454032104,
      "duration" : 623
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "fw_info::0",
    "time" : {
      "start" : 1733454032166,
      "stop" : 1733454032168,
      "duration" : 2
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "tag::0",
    "time" : {
      "start" : 1733454029622,
      "stop" : 1733454031474,
      "duration" : 1852
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "artifact::0",
    "time" : {
      "start" : 1733454031476,
      "stop" : 1733454031477,
      "duration" : 1
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "release::0",
    "time" : {
      "start" : 1733453993488,
      "stop" : 1733454029620,
      "duration" : 36132
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "board::0",
    "time" : {
      "start" : 1733454032108,
      "stop" : 1733454032109,
      "duration" : 1
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "project::0",
    "time" : {
      "start" : 1733454032106,
      "stop" : 1733454032106,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  } ],
  "labels" : [ {
    "name" : "tag",
    "value" : "esp32_devkitc_wrover_espidf"
  }, {
    "name" : "tag",
    "value" : "esp-idf"
  }, {
    "name" : "parentSuite",
    "value" : "sample.esp-idf.esp32_devkitc_wrover_espidf"
  }, {
    "name" : "tag",
    "value" : "mikes_orange_pi"
  }, {
    "name" : "tag",
    "value" : "@pytest.mark.usefixtures('anyio_backend')"
  }, {
    "name" : "tag",
    "value" : "anyio"
  }, {
    "name" : "suite",
    "value" : "test_sample"
  }, {
    "name" : "host",
    "value" : "7b0d40c6d18b"
  }, {
    "name" : "thread",
    "value" : "282-MainThread"
  }, {
    "name" : "framework",
    "value" : "pytest"
  }, {
    "name" : "language",
    "value" : "cpython3"
  }, {
    "name" : "package",
    "value" : "examples.esp_idf.fw_update.pytest.test_sample"
  }, {
    "name" : "resultFormat",
    "value" : "allure2"
  } ],
  "parameters" : [ {
    "name" : "board_name",
    "value" : "'esp32_devkitc_wrover_espidf'"
  }, {
    "name" : "platform_name",
    "value" : "'esp-idf'"
  } ],
  "links" : [ ],
  "hidden" : false,
  "retry" : false,
  "extra" : {
    "severity" : "normal",
    "retries" : [ ],
    "categories" : [ {
      "name" : "Product defects",
      "matchedStatuses" : [ ],
      "flaky" : false
    } ],
    "history" : {
      "statistic" : {
        "failed" : 1,
        "broken" : 4,
        "skipped" : 0,
        "passed" : 102,
        "unknown" : 0,
        "total" : 107
      },
      "items" : [ {
        "uid" : "ecd0ecbdfe194830",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1870/#testresult/ecd0ecbdfe194830",
        "status" : "passed",
        "time" : {
          "start" : 1733442862934,
          "stop" : 1733442999077,
          "duration" : 136143
        }
      }, {
        "uid" : "35e0cea96a0284f3",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1868/#testresult/35e0cea96a0284f3",
        "status" : "passed",
        "time" : {
          "start" : 1733415364497,
          "stop" : 1733415505826,
          "duration" : 141329
        }
      }, {
        "uid" : "1c64fed8a202d586",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1865/#testresult/1c64fed8a202d586",
        "status" : "passed",
        "time" : {
          "start" : 1733353118012,
          "stop" : 1733353246947,
          "duration" : 128935
        }
      }, {
        "uid" : "af270508bf2f15a",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1864/#testresult/af270508bf2f15a",
        "status" : "passed",
        "time" : {
          "start" : 1733329188500,
          "stop" : 1733329317274,
          "duration" : 128774
        }
      }, {
        "uid" : "cc3fef590560c2b7",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1862/#testresult/cc3fef590560c2b7",
        "status" : "passed",
        "time" : {
          "start" : 1733254638223,
          "stop" : 1733254783957,
          "duration" : 145734
        }
      }, {
        "uid" : "de723b7efb337381",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1860/#testresult/de723b7efb337381",
        "status" : "passed",
        "time" : {
          "start" : 1733191493342,
          "stop" : 1733191653005,
          "duration" : 159663
        }
      }, {
        "uid" : "ad6feae9c7329c10",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1848/#testresult/ad6feae9c7329c10",
        "status" : "passed",
        "time" : {
          "start" : 1732729925914,
          "stop" : 1732730048490,
          "duration" : 122576
        }
      }, {
        "uid" : "39002d3e362f927c",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1852//#testresult/39002d3e362f927c",
        "status" : "passed",
        "time" : {
          "start" : 1732750312361,
          "stop" : 1732750432802,
          "duration" : 120441
        }
      }, {
        "uid" : "739e7407079f6380",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1848/#testresult/739e7407079f6380",
        "status" : "passed",
        "time" : {
          "start" : 1732729925914,
          "stop" : 1732730048490,
          "duration" : 122576
        }
      }, {
        "uid" : "b6dce535a9973ada",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1847//#testresult/b6dce535a9973ada",
        "status" : "broken",
        "statusDetails" : "SystemExit: 2",
        "time" : {
          "start" : 1732724222227,
          "stop" : 1732724222227,
          "duration" : 0
        }
      }, {
        "uid" : "e81d22033ace9e62",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1844//#testresult/e81d22033ace9e62",
        "status" : "passed",
        "time" : {
          "start" : 1732631961365,
          "stop" : 1732632100010,
          "duration" : 138645
        }
      }, {
        "uid" : "4ad2e1d998617469",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1844//#testresult/4ad2e1d998617469",
        "status" : "passed",
        "time" : {
          "start" : 1732631961365,
          "stop" : 1732632100010,
          "duration" : 138645
        }
      }, {
        "uid" : "c6d7eb6c72d6cdf9",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1841//#testresult/c6d7eb6c72d6cdf9",
        "status" : "passed",
        "time" : {
          "start" : 1732560661404,
          "stop" : 1732560782869,
          "duration" : 121465
        }
      }, {
        "uid" : "a70d4b6e34a47f5c",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1841//#testresult/a70d4b6e34a47f5c",
        "status" : "passed",
        "time" : {
          "start" : 1732560661404,
          "stop" : 1732560782869,
          "duration" : 121465
        }
      }, {
        "uid" : "7e2e09e8b15bf67b",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1840//#testresult/7e2e09e8b15bf67b",
        "status" : "passed",
        "time" : {
          "start" : 1732554880801,
          "stop" : 1732555004101,
          "duration" : 123300
        }
      }, {
        "uid" : "fa2cd66a7a6716d8",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1839//#testresult/fa2cd66a7a6716d8",
        "status" : "passed",
        "time" : {
          "start" : 1732509626091,
          "stop" : 1732509754489,
          "duration" : 128398
        }
      }, {
        "uid" : "b933f1af4de9ceae",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1839//#testresult/b933f1af4de9ceae",
        "status" : "passed",
        "time" : {
          "start" : 1732509626091,
          "stop" : 1732509754489,
          "duration" : 128398
        }
      }, {
        "uid" : "28860799a3d55306",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1835//#testresult/28860799a3d55306",
        "status" : "passed",
        "time" : {
          "start" : 1732313573459,
          "stop" : 1732313702457,
          "duration" : 128998
        }
      }, {
        "uid" : "88140ea036616e21",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1835//#testresult/88140ea036616e21",
        "status" : "passed",
        "time" : {
          "start" : 1732313573459,
          "stop" : 1732313702457,
          "duration" : 128998
        }
      }, {
        "uid" : "cb14c200a406cb50",
        "reportUrl" : "https://golioth.github.io/allure-reports/branch/1835//#testresult/cb14c200a406cb50",
        "status" : "passed",
        "time" : {
          "start" : 1732313573459,
          "stop" : 1732313702457,
          "duration" : 128998
        }
      } ]
    },
    "tags" : [ "mikes_orange_pi", "esp-idf", "anyio", "esp32_devkitc_wrover_espidf", "@pytest.mark.usefixtures('anyio_backend')" ]
  },
  "source" : "cf257291e6f5e283.json",
  "parameterValues" : [ "'esp32_devkitc_wrover_espidf'", "'esp-idf'" ]
}